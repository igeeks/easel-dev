{
  "name": "Easel-dev",
  "tagline": "Easel Developer Docs",
  "body": "# Executor Function\r\n\r\nThe executor function takes 3 arguments.\r\n\r\n```\r\nargs:\r\n  params: Object // The user-defined parameters your app exposes, see below\r\n  material:\r\n    name: String // Name of active material\r\n    textureUrl: String // URL of material thumbnail image\r\n    dimensions:\r\n      x: number // Width of material in inches\r\n      y: number // Length of material in inches\r\n      z: number // Height of material in inches\r\n  bitParams:\r\n    bit:\r\n      id: String // Identifier for the bit\r\n      width: Number // Width of the bit\r\n      unit: String (\"mm\" or \"in\") // Units the width is expressed in\r\n    detailBit:   // Not present if only using 1 bit\r\n      id: String // Identifier for the detail bit\r\n      width: Number // Width of the detail bit\r\n      unit: String (\"mm\" or \"in\") // Units the width is expressed in\r\n  volumes: Array // The objects defined in the design, ordered from back to front (see below for more)\r\n  selectedVolumeIds: Array // String ids of volumes currently selected in the design\r\n```\r\n\r\nThe `params` object will have a shape matching the properties that your app gives the user to manipulate. For example, if you make two Number properties named \"Width\" and \"Height\" available, then you would receive a params object like this:\r\n\r\n```\r\nparams:\r\n  Width: Number\r\n  Height: Number\r\n```\r\n\r\nA user's design is represented by `volume` objects in Easel. We call them `volumes` because they represent a three dimensional volume of material to be removed from the work piece. In the array given to your app, volumes are ordered from back to front as the user looks at their canvas. Therefore, the last volume is in front of all other volumes, and the first volume is behind all other volumes. Front-to-back ordering is important in Easel because it affects how volumes get carved out:\r\n\r\n1. A (filled) volume whose cut depth is shallower than a volume behind it will \"lift\" material out of the volume behind it\r\n2. A volume whose cut depth is deeper than an object behind it will \"push\" material down into that shape\r\n3. Volumes can't \"raise\" or \"push\" on volumes in front of them\r\n\r\nBasically, in terms of cut depth, each volume in the array overrides all overlapping volumes that came before it.\r\n\r\nProperties that are shared across all volumes are:\r\n\r\n```\r\nvolume:\r\n  shape:\r\n    type: String // \"rectangle\", \"ellipse\", \"polygon\", \"path\", \"polyline\", \"line\"\r\n    flipping: // May be undefined, which is the same as x/y false\r\n      x: Boolean // True if the shape is \"flipped\" horizontally\r\n      y: Boolean // True if the shape is \"flipped\" vertically\r\n    center: // Most shapes (except Lines) have a center\r\n      x: Number // Absolute horizontal position in inches of the shape's center, relative to the zero point\r\n      y: Number // Absolute vertical position in inches of the shape's center, relative to the zero point\r\n    width: Number    // Width in inches of the shape\r\n    height: Number   // Height in inches of the shape\r\n    rotation: Number // Amount of counter-clockwise rotation in radians\r\n  cut:\r\n    depth: Number // Depth of cut for this shape in inches\r\n    type: String ('outline' or 'fill') // Type of cut\r\n    outlineStyle: String ('on-path', 'outside', 'inside') // Outline style, if outline cut\r\n    tabPreference: Boolean // Whether the user wants to use tabs, if cut-through outline cut\r\n    tabHeight: Number // Height (from bottom of material) of tabs in inches\r\n    tabLength: Number // Length of tabs in inches\r\n    tabs: Array // Objects with a shape of {center: {x: Number, y: Number}} representing the center location of the tabs\r\n```\r\n\r\nIn addition, shapes often have some properties specific to their type:\r\n\r\nPolygon (including Triangles)\r\n```\r\nshape:\r\n  points: Array\r\n```\r\n\r\nWhere each point in the array has the following shape:\r\n```\r\n{\r\n  x: Number // Horizontal position of point\r\n  y: Number // Vertical position of point\r\n}\r\n```\r\n\r\nPath\r\n```\r\nshape:\r\n  points: Array\r\n```\r\n\r\nWhere each point in the array has the following shape:\r\n\r\n```\r\n{\r\n  x: Number // Horizontal position of point\r\n  y: Number // Vertical position of point\r\n  lh: // Optional \"left handle\"\r\n    x: Number // Horizontal position of left handle RELATIVE to the point\r\n    y: Number // Vertical position of left handle RELATIVE to the point\r\n  rh: // Optional \"right handle\"\r\n    x: Number // Horizontal position of right handle RELATIVE TO THE POINT\r\n    y: Number // Vertical position of right handle RELATIVE TO THE POINT\r\n}\r\n```\r\n\r\nPoints will have handles if the path curves around them (on one side or the other). The handles represent the (relative) locations of bezier control points. In the v2 apps API, Easel provides functions to map from an Easel path to an SVG path.\r\n\r\n# Responses\r\n\r\nEasel passes 2 additional arguments to your app: a `success` callback and a `failure` callback.\r\n\r\nIf your app is able to function properly and produce output, it should invoke the `success` callback, passing an array of volumes having the same structure as above. The only wrinkle is with how to handle the update model--whether you want to add, replace, or remove volumes from the existing design.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}